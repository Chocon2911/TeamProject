<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>report</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="process-execution-in-solaris-operating-system">Process Execution
in SOLARIS Operating System</h1>
<h2
id="a-comprehensive-analysis-of-multiprocess-and-multithread-execution-in-multicore-systems">A
Comprehensive Analysis of Multiprocess and Multithread Execution in
Multicore Systems</h2>
<p><strong>Course:</strong> CS4448 - Operating Systems
<strong>Institution:</strong> Hanoi University of Science and Technology
<strong>Date:</strong> January 2026</p>
<hr />
<h2 id="abstract">Abstract</h2>
<p>This document presents a detailed analysis of process and thread
execution in the SOLARIS operating system, with particular emphasis on
multicore architectures. SOLARIS, developed by Sun Microsystems (now
Oracle), implements a sophisticated two-level thread model and a
comprehensive nine-state process lifecycle that serves as a reference
implementation for modern operating systems. This study examines the
mechanisms by which SOLARIS manages concurrent execution of multiple
processes and threads across multiple processor cores, including process
creation, thread management, state transitions, and scheduling
algorithms.</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#1-introduction">Introduction</a></li>
<li><a href="#2-solaris-process-model">SOLARIS Process Model</a></li>
<li><a href="#3-solaris-thread-model">SOLARIS Thread Model</a></li>
<li><a href="#4-process-state-transitions">Process State
Transitions</a></li>
<li><a href="#5-multicore-scheduling-architecture">Multicore Scheduling
Architecture</a></li>
<li><a href="#6-conclusion">Conclusion</a></li>
<li><a href="#7-references">References</a></li>
</ol>
<hr />
<h2 id="introduction">1. Introduction</h2>
<h3 id="background">1.1 Background</h3>
<p>SOLARIS is a UNIX-based operating system that has been instrumental
in advancing operating system design, particularly in the areas of
symmetric multiprocessing (SMP), thread management, and enterprise-grade
reliability. Originally developed by Sun Microsystems in 1992, SOLARIS
has evolved to become one of the most sophisticated commercial operating
systems, now maintained by Oracle Corporation.</p>
<p>The study of SOLARIS process execution is particularly relevant
because it implements concepts that have been adopted by many modern
operating systems, including Linux and modern Windows variants.
Understanding how SOLARIS manages processes and threads in multicore
environments provides valuable insights into operating system design
principles.</p>
<h3 id="key-characteristics-of-solaris">1.2 Key Characteristics of
SOLARIS</h3>
<table>
<colgroup>
<col style="width: 55%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Characteristic</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Kernel Architecture</strong></td>
<td>Fully preemptible, multithreaded monolithic kernel</td>
</tr>
<tr class="even">
<td><strong>Thread Model</strong></td>
<td>Two-level model with user threads, LWPs, and kernel threads</td>
</tr>
<tr class="odd">
<td><strong>Scheduling</strong></td>
<td>Class-based priority scheduling with multiple scheduling
classes</td>
</tr>
<tr class="even">
<td><strong>Memory Model</strong></td>
<td>Virtual memory with demand paging and copy-on-write
optimization</td>
</tr>
<tr class="odd">
<td><strong>Scalability</strong></td>
<td>Supports systems from single processor to thousands of cores</td>
</tr>
<tr class="even">
<td><strong>Standards Compliance</strong></td>
<td>POSIX-compliant, UNIX 03 certified</td>
</tr>
</tbody>
</table>
<h3 id="scope-of-analysis">1.3 Scope of Analysis</h3>
<p>This document examines: - The structure and lifecycle of SOLARIS
processes - The two-level thread model and its implications for
multicore execution - The nine-state process state transition model -
Scheduling mechanisms for multicore systems - The relationship between
user-level and kernel-level execution contexts</p>
<hr />
<h2 id="solaris-process-model">2. SOLARIS Process Model</h2>
<h3 id="definition-and-structure">2.1 Definition and Structure</h3>
<p>In SOLARIS, a <strong>process</strong> is defined as an instance of a
program in execution, encompassing all resources necessary for program
execution. Unlike simpler operating systems, SOLARIS processes are
designed as containers that can hold multiple threads of execution, each
capable of independent scheduling on multicore systems.</p>
<pre class="mermaid"><code>graph TB
    subgraph Process[&quot;SOLARIS Process Structure&quot;]
        direction TB
        PID[&quot;Process Identifier (PID)&lt;br/&gt;Unique system-wide identifier&quot;]

        subgraph AddressSpace[&quot;Virtual Address Space&quot;]
            TEXT[&quot;Text Segment&lt;br/&gt;(Executable Code)&quot;]
            DATA[&quot;Data Segment&lt;br/&gt;(Initialized Variables)&quot;]
            BSS[&quot;BSS Segment&lt;br/&gt;(Uninitialized Variables)&quot;]
            HEAP[&quot;Heap&lt;br/&gt;(Dynamic Allocation)&quot;]
            STACK[&quot;Stack(s)&lt;br/&gt;(One per Thread)&quot;]
        end

        subgraph Resources[&quot;Process Resources&quot;]
            FDT[&quot;File Descriptor Table&quot;]
            SIG[&quot;Signal Handlers&quot;]
            CRED[&quot;Credentials (UID/GID)&quot;]
            LWP[&quot;LWP Pool&quot;]
        end

        PCB[&quot;Process Control Block (proc_t)&quot;]
    end</code></pre>
<h3 id="process-control-block-pcb">2.2 Process Control Block (PCB)</h3>
<p>The Process Control Block in SOLARIS, implemented as the
<code>proc_t</code> structure, contains comprehensive information
required for process management:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 35%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>PCB Component</th>
<th>Description</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Process Identification</strong></td>
<td>PID, PPID, PGID, SID</td>
<td>Unique identification and process hierarchy</td>
</tr>
<tr class="even">
<td><strong>Process State</strong></td>
<td>Current state in lifecycle</td>
<td>Scheduling decisions</td>
</tr>
<tr class="odd">
<td><strong>CPU Context</strong></td>
<td>Registers, program counter, stack pointer</td>
<td>Context switching</td>
</tr>
<tr class="even">
<td><strong>Memory Management</strong></td>
<td>Page tables, memory maps</td>
<td>Address translation</td>
</tr>
<tr class="odd">
<td><strong>Scheduling Information</strong></td>
<td>Priority, scheduling class, CPU time</td>
<td>Scheduler decisions</td>
</tr>
<tr class="even">
<td><strong>Credentials</strong></td>
<td>UID, GID, capabilities</td>
<td>Security and access control</td>
</tr>
<tr class="odd">
<td><strong>Resource Limits</strong></td>
<td>CPU time, memory, file descriptors</td>
<td>Resource management</td>
</tr>
<tr class="even">
<td><strong>Accounting Information</strong></td>
<td>CPU usage, creation time</td>
<td>System accounting</td>
</tr>
</tbody>
</table>
<h3 id="process-creation-mechanism">2.3 Process Creation Mechanism</h3>
<p>SOLARIS implements process creation through the <code>fork()</code>
system call, following the traditional UNIX model with significant
optimizations.</p>
<p><strong>fork() Process Creation Steps:</strong></p>
<ol type="1">
<li>Parent process invokes <code>fork()</code> system call</li>
<li>Kernel allocates new PID for child process</li>
<li>Kernel creates new <code>proc_t</code> structure (PCB)</li>
<li>Kernel copies parent’s PCB to child</li>
<li>Memory Manager sets up Copy-on-Write mappings</li>
<li>Child inherits file descriptors and signal handlers</li>
<li>Kernel creates initial LWP for child</li>
<li><code>fork()</code> returns child PID to parent, returns 0 to
child</li>
<li>Both processes execute concurrently</li>
</ol>
<p><strong>Copy-on-Write (COW) Optimization:</strong> SOLARIS employs
copy-on-write semantics during fork(), where parent and child initially
share physical memory pages marked as read-only. Physical copying occurs
only when either process attempts to modify a shared page, significantly
reducing the overhead of process creation.</p>
<h3 id="process-hierarchy-and-relationships">2.4 Process Hierarchy and
Relationships</h3>
<p>SOLARIS maintains a hierarchical process structure rooted at process
0 (the scheduler/swapper):</p>
<pre class="mermaid"><code>graph TB
    P0[&quot;Process 0&lt;br/&gt;(sched - Swapper)&quot;]
    P1[&quot;Process 1&lt;br/&gt;(init)&quot;]
    P2[&quot;Process 2&lt;br/&gt;(pageout)&quot;]
    P3[&quot;Process 3&lt;br/&gt;(fsflush)&quot;]

    U1[&quot;User Process&lt;br/&gt;(Shell)&quot;]
    U2[&quot;User Process&lt;br/&gt;(Application)&quot;]
    U3[&quot;User Process&lt;br/&gt;(Daemon)&quot;]

    C1[&quot;Child Process&quot;]
    C2[&quot;Child Process&quot;]

    P0 --&gt; P1
    P0 --&gt; P2
    P0 --&gt; P3

    P1 --&gt; U1
    P1 --&gt; U2
    P1 --&gt; U3

    U1 --&gt; C1
    U2 --&gt; C2</code></pre>
<h3 id="process-lifecycle-system-calls">2.5 Process Lifecycle System
Calls</h3>
<table>
<thead>
<tr class="header">
<th>System Call</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fork()</code></td>
<td>Create process</td>
<td>Creates exact copy of calling process</td>
</tr>
<tr class="even">
<td><code>exec()</code></td>
<td>Load program</td>
<td>Replaces process image with new program</td>
</tr>
<tr class="odd">
<td><code>exit()</code></td>
<td>Terminate</td>
<td>Terminates process, releases resources</td>
</tr>
<tr class="even">
<td><code>wait()</code></td>
<td>Synchronize</td>
<td>Parent waits for child termination</td>
</tr>
<tr class="odd">
<td><code>getpid()</code></td>
<td>Identification</td>
<td>Returns process ID</td>
</tr>
<tr class="even">
<td><code>getppid()</code></td>
<td>Identification</td>
<td>Returns parent process ID</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="solaris-thread-model">3. SOLARIS Thread Model</h2>
<h3 id="two-level-thread-architecture">3.1 Two-Level Thread
Architecture</h3>
<p>SOLARIS implements a sophisticated <strong>two-level thread
model</strong> (also known as the M:N model) that provides flexibility
and efficiency in thread management. This model distinguishes between
three types of execution contexts:</p>
<pre class="mermaid"><code>graph TB
    subgraph UserSpace[&quot;User Space&quot;]
        direction LR
        UT1[&quot;User Thread 1&quot;]
        UT2[&quot;User Thread 2&quot;]
        UT3[&quot;User Thread 3&quot;]
        UT4[&quot;User Thread 4&quot;]
        UT5[&quot;User Thread 5&quot;]

        TL[&quot;Thread Library&lt;br/&gt;(libthread)&quot;]
    end

    subgraph KernelBoundary[&quot;Kernel Boundary&quot;]
        LWP1[&quot;LWP 1&quot;]
        LWP2[&quot;LWP 2&quot;]
        LWP3[&quot;LWP 3&quot;]
    end

    subgraph KernelSpace[&quot;Kernel Space&quot;]
        KT1[&quot;Kernel Thread 1&quot;]
        KT2[&quot;Kernel Thread 2&quot;]
        KT3[&quot;Kernel Thread 3&quot;]

        SCHED[&quot;Kernel Scheduler&quot;]
    end

    subgraph Hardware[&quot;Multicore Processor&quot;]
        CPU0[&quot;Core 0&quot;]
        CPU1[&quot;Core 1&quot;]
    end

    UT1 &amp; UT2 --&gt; LWP1
    UT3 --&gt; LWP2
    UT4 &amp; UT5 --&gt; LWP3

    LWP1 --&gt; KT1
    LWP2 --&gt; KT2
    LWP3 --&gt; KT3

    KT1 &amp; KT2 &amp; KT3 --&gt; SCHED

    SCHED --&gt; CPU0
    SCHED --&gt; CPU1</code></pre>
<h3 id="thread-type-characteristics">3.2 Thread Type
Characteristics</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 40%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>Attribute</th>
<th>User Thread</th>
<th>Lightweight Process (LWP)</th>
<th>Kernel Thread</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Management</strong></td>
<td>Thread library</td>
<td>Kernel</td>
<td>Kernel</td>
</tr>
<tr class="even">
<td><strong>Visibility</strong></td>
<td>Application only</td>
<td>Kernel visible</td>
<td>Kernel only</td>
</tr>
<tr class="odd">
<td><strong>Creation Cost</strong></td>
<td>Very low</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr class="even">
<td><strong>Context Switch</strong></td>
<td>Fast (user space)</td>
<td>Slow (kernel mode)</td>
<td>Slow (kernel mode)</td>
</tr>
<tr class="odd">
<td><strong>Scheduling</strong></td>
<td>Thread library</td>
<td>Kernel scheduler</td>
<td>Kernel scheduler</td>
</tr>
<tr class="even">
<td><strong>Blocking</strong></td>
<td>May block LWP</td>
<td>Blocks kernel thread</td>
<td>Blocks CPU</td>
</tr>
<tr class="odd">
<td><strong>Parallelism</strong></td>
<td>Limited by LWPs</td>
<td>True parallelism</td>
<td>True parallelism</td>
</tr>
</tbody>
</table>
<h3 id="lightweight-processes-lwps">3.3 Lightweight Processes
(LWPs)</h3>
<p>LWPs serve as the bridge between user threads and kernel threads,
providing several critical functions:</p>
<ol type="1">
<li><p><strong>Kernel Execution Context:</strong> Each LWP provides a
context for executing system calls on behalf of user threads.</p></li>
<li><p><strong>Scheduling Entity:</strong> LWPs are the entities
scheduled by the kernel, allowing true parallel execution on multicore
systems.</p></li>
<li><p><strong>Signal Delivery:</strong> Signals are delivered to LWPs,
which then dispatch them to appropriate user threads.</p></li>
<li><p><strong>Resource Accounting:</strong> CPU time and other
resources are accounted at the LWP level.</p></li>
</ol>
<pre class="mermaid"><code>flowchart LR
    subgraph LWP_Structure[&quot;LWP Structure (klwp_t)&quot;]
        direction TB
        LWPID[&quot;LWP ID&quot;]
        PCB_REF[&quot;Process Reference&quot;]
        KTHREAD[&quot;Kernel Thread Pointer&quot;]
        UCONTEXT[&quot;User Context&quot;]
        SIGPEND[&quot;Pending Signals&quot;]
        SCLASS[&quot;Scheduling Class&quot;]
    end

    UT[&quot;User Thread&quot;] --&gt; LWP_Structure
    LWP_Structure --&gt; KT[&quot;Kernel Thread&quot;]
    KT --&gt; CPU[&quot;CPU Core&quot;]</code></pre>
<h3 id="thread-synchronization-primitives">3.4 Thread Synchronization
Primitives</h3>
<p>SOLARIS provides multiple synchronization primitives for coordinating
thread execution:</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 25%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>Primitive</th>
<th>Scope</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Mutex Locks</strong></td>
<td>Process/System</td>
<td>Mutual exclusion for critical sections</td>
</tr>
<tr class="even">
<td><strong>Condition Variables</strong></td>
<td>Process</td>
<td>Thread coordination and signaling</td>
</tr>
<tr class="odd">
<td><strong>Semaphores</strong></td>
<td>Process/System</td>
<td>Resource counting and synchronization</td>
</tr>
<tr class="even">
<td><strong>Reader-Writer Locks</strong></td>
<td>Process</td>
<td>Multiple readers, exclusive writers</td>
</tr>
<tr class="odd">
<td><strong>Barriers</strong></td>
<td>Process</td>
<td>Synchronization points for thread groups</td>
</tr>
</tbody>
</table>
<h3 id="thread-creation-and-management">3.5 Thread Creation and
Management</h3>
<p><strong>Thread Creation Steps (pthread_create):</strong></p>
<ol type="1">
<li>Application calls <code>pthread_create()</code></li>
<li>Thread library allocates thread stack</li>
<li>Thread library initializes thread context</li>
<li>If needed, library requests new LWP via
<code>lwp_create()</code></li>
<li>Kernel allocates kernel thread for LWP</li>
<li>Library maps user thread to LWP</li>
<li>Thread ID returned to application</li>
<li>Thread executes concurrently with other threads</li>
</ol>
<p><strong>Thread Termination Steps (pthread_join):</strong></p>
<ol type="1">
<li>Application calls <code>pthread_join()</code></li>
<li>Thread library waits for thread completion</li>
<li>Library collects exit status</li>
<li>Resources deallocated</li>
<li>Control returns to caller</li>
</ol>
<hr />
<h2 id="process-state-transitions">4. Process State Transitions</h2>
<h3 id="the-nine-state-model">4.1 The Nine-State Model</h3>
<p>SOLARIS implements a comprehensive nine-state process model that
accurately reflects the various conditions a process may experience
during its lifecycle. This model is more detailed than simpler
five-state models and accounts for memory management states.</p>
<pre class="mermaid"><code>stateDiagram-v2
    [*] --&gt; CREATED: fork()

    CREATED --&gt; READY_MEMORY: Admit\n(sufficient memory)
    CREATED --&gt; READY_SWAPPED: Admit\n(insufficient memory)

    READY_SWAPPED --&gt; READY_MEMORY: Swap In
    READY_MEMORY --&gt; READY_SWAPPED: Swap Out\n(memory pressure)

    READY_MEMORY --&gt; KERNEL_RUNNING: Dispatch\n(context switch)

    KERNEL_RUNNING --&gt; USER_RUNNING: Return to User Mode\n(iret instruction)
    USER_RUNNING --&gt; KERNEL_RUNNING: System Call\nor Interrupt

    KERNEL_RUNNING --&gt; PREEMPTED: Preemption\n(higher priority ready)
    USER_RUNNING --&gt; KERNEL_RUNNING: Timer Interrupt\n(quantum expired)
    KERNEL_RUNNING --&gt; PREEMPTED: Quantum Expired
    PREEMPTED --&gt; READY_MEMORY: Reschedule

    KERNEL_RUNNING --&gt; SLEEP: Blocking Operation\n(I/O, lock, wait)
    SLEEP --&gt; READY_MEMORY: Event Completion\n(I/O done, signal)
    SLEEP --&gt; SLEEP_SWAPPED: Swap Out
    SLEEP_SWAPPED --&gt; SLEEP: Swap In
    SLEEP_SWAPPED --&gt; READY_SWAPPED: Event while Swapped

    KERNEL_RUNNING --&gt; ZOMBIE: exit()\n(process termination)
    ZOMBIE --&gt; [*]: Parent calls wait()\n(PCB deallocated)</code></pre>
<h3 id="state-definitions">4.2 State Definitions</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 33%" />
<col style="width: 27%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th>Memory Location</th>
<th>CPU Assigned</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>CREATED</strong></td>
<td>N/A</td>
<td>No</td>
<td>Process structure created; resources being allocated</td>
</tr>
<tr class="even">
<td><strong>READY_MEMORY</strong></td>
<td>Main Memory</td>
<td>No</td>
<td>Ready to execute; waiting for CPU assignment</td>
</tr>
<tr class="odd">
<td><strong>READY_SWAPPED</strong></td>
<td>Swap Space</td>
<td>No</td>
<td>Ready to execute; swapped out due to memory pressure</td>
</tr>
<tr class="even">
<td><strong>KERNEL_RUNNING</strong></td>
<td>Main Memory</td>
<td>Yes</td>
<td>Executing in kernel mode (privileged)</td>
</tr>
<tr class="odd">
<td><strong>USER_RUNNING</strong></td>
<td>Main Memory</td>
<td>Yes</td>
<td>Executing in user mode (unprivileged)</td>
</tr>
<tr class="even">
<td><strong>PREEMPTED</strong></td>
<td>Main Memory</td>
<td>No</td>
<td>Execution interrupted; will resume when rescheduled</td>
</tr>
<tr class="odd">
<td><strong>SLEEP</strong></td>
<td>Main Memory</td>
<td>No</td>
<td>Blocked waiting for event (I/O, lock, signal)</td>
</tr>
<tr class="even">
<td><strong>SLEEP_SWAPPED</strong></td>
<td>Swap Space</td>
<td>No</td>
<td>Blocked and swapped out</td>
</tr>
<tr class="odd">
<td><strong>ZOMBIE</strong></td>
<td>N/A</td>
<td>No</td>
<td>Terminated; awaiting parent to collect exit status</td>
</tr>
</tbody>
</table>
<h3 id="critical-transition-kernel-mode-requirement">4.3 Critical
Transition: Kernel Mode Requirement</h3>
<p>A fundamental principle in SOLARIS (and UNIX systems generally) is
that <strong>all state transitions must pass through kernel
mode</strong>. This design ensures:</p>
<ol type="1">
<li><strong>Security:</strong> Only privileged kernel code can modify
process states</li>
<li><strong>Resource Management:</strong> Kernel maintains consistent
resource accounting</li>
<li><strong>Synchronization:</strong> State changes are atomic and
properly synchronized</li>
<li><strong>Audit Trail:</strong> All transitions can be logged for
security purposes</li>
</ol>
<pre class="mermaid"><code>flowchart TD
    subgraph Principle[&quot;Kernel Mode Transition Principle&quot;]
        A[&quot;Any Process State&quot;]
        B[&quot;KERNEL_RUNNING&lt;br/&gt;(Mandatory Intermediate State)&quot;]
        C[&quot;New Process State&quot;]

        A --&gt;|&quot;Trap/Interrupt&quot;| B
        B --&gt;|&quot;State Change&quot;| C
    end

    style B fill:#ffcc00,stroke:#333,stroke-width:2px</code></pre>
<h3 id="state-transition-scenarios">4.4 State Transition Scenarios</h3>
<p><strong>Scenario 1: Normal Process Execution Cycle</strong></p>
<pre><code>READY_MEMORY → KERNEL_RUNNING → USER_RUNNING → KERNEL_RUNNING → PREEMPTED → READY_MEMORY</code></pre>
<p>This cycle represents normal time-sharing where a process executes
until its quantum expires.</p>
<p><strong>Scenario 2: I/O Operation</strong></p>
<pre><code>USER_RUNNING → KERNEL_RUNNING → SLEEP → READY_MEMORY → KERNEL_RUNNING → USER_RUNNING</code></pre>
<p>Process blocks on I/O, sleeps until completion, then resumes
execution.</p>
<p><strong>Scenario 3: Process Termination</strong></p>
<pre><code>USER_RUNNING → KERNEL_RUNNING → ZOMBIE → [Destroyed]</code></pre>
<p>Process calls exit(), enters zombie state until parent collects
status.</p>
<p><strong>Scenario 4: Memory Pressure</strong></p>
<pre><code>READY_MEMORY → READY_SWAPPED → READY_MEMORY → KERNEL_RUNNING</code></pre>
<p>Process swapped out due to memory pressure, later swapped back
in.</p>
<h3 id="transition-triggers">4.5 Transition Triggers</h3>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Transition</th>
<th>Trigger</th>
<th>Handler</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CREATED → READY</td>
<td>Sufficient resources allocated</td>
<td>Process Manager</td>
</tr>
<tr class="even">
<td>READY → KERNEL_RUNNING</td>
<td>Scheduler selects process</td>
<td>Dispatcher</td>
</tr>
<tr class="odd">
<td>KERNEL_RUNNING → USER_RUNNING</td>
<td>Return from system call</td>
<td>Dispatcher</td>
</tr>
<tr class="even">
<td>USER_RUNNING → KERNEL_RUNNING</td>
<td>System call or interrupt</td>
<td>Trap Handler</td>
</tr>
<tr class="odd">
<td>KERNEL_RUNNING → PREEMPTED</td>
<td>Time quantum expires</td>
<td>Scheduler</td>
</tr>
<tr class="even">
<td>KERNEL_RUNNING → SLEEP</td>
<td>Blocking I/O request</td>
<td>I/O Subsystem</td>
</tr>
<tr class="odd">
<td>SLEEP → READY</td>
<td>I/O completion interrupt</td>
<td>Interrupt Handler</td>
</tr>
<tr class="even">
<td>KERNEL_RUNNING → ZOMBIE</td>
<td>exit() system call</td>
<td>Process Manager</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="multicore-scheduling-architecture">5. Multicore Scheduling
Architecture</h2>
<h3 id="scheduling-classes">5.1 Scheduling Classes</h3>
<p>SOLARIS implements a <strong>class-based scheduling
architecture</strong> where different types of processes can be managed
by different scheduling algorithms. Each scheduling class has its own
priority range and scheduling policy.</p>
<pre class="mermaid"><code>graph TB
    subgraph GlobalPriority[&quot;Global Priority Scale (0-169)&quot;]
        direction TB

        subgraph INT[&quot;Interrupt Threads (160-169)&quot;]
            INT_DESC[&quot;Hardware interrupt handling&lt;br/&gt;Highest priority, not preemptible&quot;]
        end

        subgraph RT[&quot;Real-Time Class (100-159)&quot;]
            RT_DESC[&quot;Fixed priority scheduling&lt;br/&gt;For time-critical applications&quot;]
        end

        subgraph SYS[&quot;System Class (60-99)&quot;]
            SYS_DESC[&quot;Kernel threads and daemons&lt;br/&gt;Fixed priority, no time slicing&quot;]
        end

        subgraph TS[&quot;Time-Sharing Class (0-59)&quot;]
            TS_DESC[&quot;Interactive processes&lt;br/&gt;Dynamic priority adjustment&quot;]
        end

        subgraph IA[&quot;Interactive Class (0-59)&quot;]
            IA_DESC[&quot;Windowed applications&lt;br/&gt;Priority boost for foreground&quot;]
        end

        subgraph FSS[&quot;Fair-Share Class (0-59)&quot;]
            FSS_DESC[&quot;Resource-controlled scheduling&lt;br/&gt;Based on shares allocation&quot;]
        end
    end

    INT --&gt; RT --&gt; SYS --&gt; TS</code></pre>
<h3 id="scheduling-class-comparison">5.2 Scheduling Class
Comparison</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 25%" />
<col style="width: 22%" />
<col style="width: 24%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>Class</th>
<th>Priority Range</th>
<th>Time Quantum</th>
<th>Priority Type</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Interrupt</strong></td>
<td>160-169</td>
<td>None</td>
<td>Fixed</td>
<td>Hardware interrupt handlers</td>
</tr>
<tr class="even">
<td><strong>Real-Time (RT)</strong></td>
<td>100-159</td>
<td>Fixed</td>
<td>Fixed</td>
<td>Real-time applications, multimedia</td>
</tr>
<tr class="odd">
<td><strong>System (SYS)</strong></td>
<td>60-99</td>
<td>Infinite</td>
<td>Fixed</td>
<td>Kernel threads, critical daemons</td>
</tr>
<tr class="even">
<td><strong>Time-Sharing (TS)</strong></td>
<td>0-59</td>
<td>Variable</td>
<td>Dynamic</td>
<td>General user processes</td>
</tr>
<tr class="odd">
<td><strong>Interactive (IA)</strong></td>
<td>0-59</td>
<td>Variable</td>
<td>Dynamic</td>
<td>GUI applications</td>
</tr>
<tr class="even">
<td><strong>Fair-Share (FSS)</strong></td>
<td>0-59</td>
<td>Variable</td>
<td>Dynamic</td>
<td>Multi-tenant environments</td>
</tr>
</tbody>
</table>
<h3 id="multiprocessor-scheduling">5.3 Multiprocessor Scheduling</h3>
<p>SOLARIS employs sophisticated mechanisms for efficient multicore
utilization:</p>
<pre class="mermaid"><code>graph TB
    subgraph MultiCore[&quot;Multicore Scheduling Architecture&quot;]

        subgraph DispatchQueues[&quot;Per-CPU Dispatch Queues&quot;]
            DQ0[&quot;CPU 0 Queue&quot;]
            DQ1[&quot;CPU 1 Queue&quot;]
            DQ2[&quot;CPU 2 Queue&quot;]
            DQn[&quot;CPU n Queue&quot;]
        end

        subgraph LoadBalancer[&quot;Load Balancing&quot;]
            LB[&quot;Dispatcher&quot;]
            PULL[&quot;Pull Migration&lt;br/&gt;(Idle CPU pulls work)&quot;]
            PUSH[&quot;Push Migration&lt;br/&gt;(Busy CPU offloads)&quot;]
        end

        subgraph Processors[&quot;Physical Processors&quot;]
            P0[&quot;CPU 0&quot;]
            P1[&quot;CPU 1&quot;]
            P2[&quot;CPU 2&quot;]
            Pn[&quot;CPU n&quot;]
        end

        DQ0 --&gt; P0
        DQ1 --&gt; P1
        DQ2 --&gt; P2
        DQn --&gt; Pn

        LB --&gt; PULL
        LB --&gt; PUSH

        PULL -.-&gt; DQ0 &amp; DQ1 &amp; DQ2 &amp; DQn
        PUSH -.-&gt; DQ0 &amp; DQ1 &amp; DQ2 &amp; DQn
    end</code></pre>
<h3 id="processor-affinity-and-numa">5.4 Processor Affinity and
NUMA</h3>
<p><strong>Processor Affinity:</strong> SOLARIS allows binding processes
or LWPs to specific processors, which can improve cache utilization:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 35%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>Affinity Type</th>
<th>Description</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Soft Affinity</strong></td>
<td>Preference for specific CPU</td>
<td>Better cache utilization</td>
</tr>
<tr class="even">
<td><strong>Hard Affinity</strong></td>
<td>Mandatory CPU binding</td>
<td>Predictable performance</td>
</tr>
<tr class="odd">
<td><strong>Processor Sets</strong></td>
<td>Dedicated CPU pools</td>
<td>Resource isolation</td>
</tr>
</tbody>
</table>
<p><strong>NUMA-Aware Scheduling:</strong> On Non-Uniform Memory Access
systems, SOLARIS considers memory locality when making scheduling
decisions, preferring to schedule threads on processors close to their
memory allocations.</p>
<h3 id="context-switching-mechanism">5.5 Context Switching
Mechanism</h3>
<p>Context switching in SOLARIS involves saving and restoring the
complete execution context. The process includes:</p>
<p><strong>Context Save Phase:</strong> 1. Current thread traps to
kernel mode 2. Kernel saves CPU registers to PCB 3. Kernel saves program
counter 4. Kernel saves stack pointer 5. Kernel saves FPU state (if
used) 6. Kernel updates accounting information</p>
<p><strong>Context Restore Phase:</strong> 1. Kernel selects next thread
to run 2. Kernel loads new page table base 3. Kernel restores CPU
registers from new PCB 4. Kernel restores program counter 5. Kernel
restores stack pointer 6. Return from kernel to new thread 7. New thread
resumes execution on CPU</p>
<h3 id="scheduling-algorithms">5.6 Scheduling Algorithms</h3>
<p><strong>Priority Scheduling:</strong> - Processes are assigned
priority levels - Higher priority processes always execute first - Can
lead to starvation of low-priority processes - Used in RT and SYS
scheduling classes</p>
<p><strong>Round Robin Scheduling:</strong> - Equal time quantum
allocated to each process - Processes execute in circular order -
Ensures fairness among equal-priority processes - Used within priority
levels in TS class</p>
<p><strong>Multilevel Feedback Queue:</strong> - Combines priority and
round robin - Processes move between queues based on behavior -
CPU-bound processes decrease in priority - I/O-bound processes maintain
higher priority</p>
<hr />
<h2 id="conclusion">6. Conclusion</h2>
<h3 id="summary-of-key-concepts">6.1 Summary of Key Concepts</h3>
<p>This analysis has examined the process execution model in SOLARIS,
revealing several fundamental principles:</p>
<ol type="1">
<li><p><strong>Two-Level Thread Model:</strong> SOLARIS’s separation of
user threads from kernel scheduling entities (LWPs) provides both
flexibility and efficiency, allowing applications to create many
lightweight threads while the kernel manages a smaller number of
schedulable entities.</p></li>
<li><p><strong>Nine-State Process Model:</strong> The comprehensive
state model accurately captures all conditions a process may experience,
including memory management states (READY_SWAPPED, SLEEP_SWAPPED) that
simpler models omit.</p></li>
<li><p><strong>Kernel Mode Transitions:</strong> The requirement that
all state transitions pass through kernel mode ensures security,
consistency, and proper resource management.</p></li>
<li><p><strong>Class-Based Scheduling:</strong> Multiple scheduling
classes allow SOLARIS to efficiently handle diverse workloads, from
real-time applications to interactive users to batch
processing.</p></li>
<li><p><strong>Multicore Optimization:</strong> Per-CPU dispatch queues,
load balancing, and NUMA-aware scheduling enable efficient utilization
of modern multicore processors.</p></li>
</ol>
<h3 id="relevance-to-modern-systems">6.2 Relevance to Modern
Systems</h3>
<p>The concepts implemented in SOLARIS continue to influence modern
operating systems:</p>
<table>
<thead>
<tr class="header">
<th>SOLARIS Concept</th>
<th>Modern Implementation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Two-level threading</td>
<td>Linux NPTL, Windows thread pools</td>
</tr>
<tr class="even">
<td>Scheduling classes</td>
<td>Linux CFS, Windows priority levels</td>
</tr>
<tr class="odd">
<td>LWPs</td>
<td>Linux tasks, Windows threads</td>
</tr>
<tr class="even">
<td>Processor affinity</td>
<td>CPU pinning in containers/VMs</td>
</tr>
<tr class="odd">
<td>NUMA awareness</td>
<td>Linux NUMA balancing, Windows NUMA API</td>
</tr>
</tbody>
</table>
<h3 id="significance-for-operating-system-education">6.3 Significance
for Operating System Education</h3>
<p>Understanding SOLARIS process execution provides essential knowledge
for: - Operating system design and implementation - System programming
and performance optimization - Concurrent and parallel programming -
Virtualization and container technologies</p>
<hr />
<h2 id="references">7. References</h2>
<ol type="1">
<li><p>Silberschatz, A., Galvin, P.B., &amp; Gagne, G. (2018).
<em>Operating System Concepts</em> (10th ed.). John Wiley &amp;
Sons.</p></li>
<li><p>Mauro, J., &amp; McDougall, R. (2006). <em>Solaris Internals:
Solaris 10 and OpenSolaris Kernel Architecture</em> (2nd ed.). Prentice
Hall.</p></li>
<li><p>McDougall, R., &amp; Mauro, J. (2006). <em>Solaris Performance
and Tools: DTrace and MDB Techniques for Solaris 10 and
OpenSolaris</em>. Prentice Hall.</p></li>
<li><p>Vahalia, U. (1996). <em>UNIX Internals: The New Frontiers</em>.
Prentice Hall.</p></li>
<li><p>Oracle Corporation. (2023). <em>Oracle Solaris 11.4 Tunable
Parameters Reference Manual</em>. Oracle Documentation.</p></li>
<li><p>Tanenbaum, A.S., &amp; Bos, H. (2014). <em>Modern Operating
Systems</em> (4th ed.). Pearson.</p></li>
<li><p>Love, R. (2010). <em>Linux Kernel Development</em> (3rd ed.).
Addison-Wesley Professional.</p></li>
<li><p>Bovet, D.P., &amp; Cesati, M. (2005). <em>Understanding the Linux
Kernel</em> (3rd ed.). O’Reilly Media.</p></li>
</ol>
<hr />
<p><em>Submitted in partial fulfillment of the requirements for CS4448 -
Operating Systems</em></p>
<p><em>Hanoi University of Science and Technology</em></p>
</body>
</html>
